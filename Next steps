I'll analyze this code line by line, focusing on how it works, the Hill function, keo, and the calculation and storage of Cp and Ce values.
Import Section
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

Standard libraries for scientific computing (NumPy), plotting (Matplotlib), and solving differential equations (SciPy's solve_ivp - Initial Value Problem solver)
Parameter Function
def get_schneider_parameters(weight=70, height=170, age=40, sex='male'):

This function calculates pharmacokinetic (PK) parameters for the Schneider model of propofol based on patient demographic data
The model parameters are individualized to the patient characteristics
# Lean body mass calculation
if sex.lower() == 'male':
    lbm = 1.1 * weight - 128 * (weight/height)**2
else:  # female
    lbm = 1.07 * weight - 148 * (weight/height)**2

Calculates lean body mass (LBM) differently based on sex
These are validated formulas that account for the different body compositions between males and females
# Volume calculations
v1 = 4.27  # L - Central compartment
v2 = 18.9 - 0.391 * (age - 53)  # L - Rapid peripheral compartment
v3 = 238  # L - Slow peripheral compartment

Defines the three compartment volumes in the model:
v1: Central compartment (blood/plasma) - fixed value
v2: Rapid peripheral compartment (highly perfused tissues) - adjusts based on age
v3: Slow peripheral compartment (poorly perfused tissues) - fixed value
# Clearance calculations
cl1 = 1.89 + 0.0456 * (weight - 77) - 0.0681 * (lbm - 59) + 0.0264 * (height - 177)  # L/min
cl2 = 1.29 - 0.024 * (age - 53)  # L/min
cl3 = 0.836  # L/min

Calculates clearance rates between compartments:
cl1: Metabolic clearance (dependent on weight, LBM, and height)
cl2: Clearance between central and rapid peripheral (age-dependent)
cl3: Clearance between central and slow peripheral (fixed)
# Calculate rate constants
k10 = cl1 / v1
k12 = cl2 / v1
k13 = cl3 / v1
k21 = cl2 / v2
k31 = cl3 / v3

Converts clearances to rate constants by dividing by respective volumes
These k-values represent the fractional rate of transfer between compartments:
k10: Elimination rate from central compartment
k12, k13: Transfer from central to peripheral compartments
k21, k31: Transfer from peripheral back to central compartment
# Effect site parameters 
keo = 0.46  # 1/min

keo is the rate constant for equilibration between plasma and effect site
The value 0.46/min means it takes about 2-3 minutes to reach equilibrium (time to peak effect)
This parameter comes from clinical studies where researchers measured both drug plasma concentrations and clinical effects (like BIS values), then calculated the time lag
# PD parameters (Hill function for BIS)
EC50 = 2.2  # mcg/mL
gamma = 1.8  # Hill coefficient
E0 = 100     # Baseline BIS value
Emax = 0     # Maximum effect (lowest BIS)

These are pharmacodynamic (PD) parameters for the Hill equation:
EC50: Concentration producing 50% of maximum effect (2.2 mcg/mL)
gamma: Hill coefficient determining steepness of the concentration-effect curve
E0: Baseline BIS value (fully awake = 100)
Emax: Maximum effect (fully anesthetized = 0)
Simulation Function
def run_simulation(model_params, weight=70, dosing_regimen=None, total_time=180, dt=0.1):

Core function that runs the PK/PD simulation using provided parameters
Takes model parameters, patient weight, dosing schedule, simulation time, and time step
# Extract parameters from dictionary
v1 = model_params['v1']
k10 = model_params['k10']
# ... other parameters extracted

Unpacks parameters from the dictionary for easier use in calculations
# Default dosing regimen if none provided
if dosing_regimen is None:
    dosing_regimen = [
        {'type': 'bolus', 'time': 0, 'dose': 2.0, 'duration': 0.1},  # mg/kg bolus at t=0
        {'type': 'infusion', 'time': 0.1, 'rate': 166.67, 'duration': 10},  # mcg/kg/min for 10 min
        # ... additional default infusions
    ]

Sets a default dosing regimen if none is provided
Contains a mix of boluses (large dose given quickly) and infusions (continuous delivery)
# Simulation time settings
t_start = 0
t_end = total_time  # minutes
t = np.arange(t_start, t_end + dt, dt)

Creates a time array from 0 to total simulation time with step size dt
This array becomes the x-axis for all plots and calculations
# Create infusion rate array and track bolus times
infusion_rates = np.zeros_like(t)
bolus_times = []

Creates an array to store infusion rates at each time point
Initializes an empty list to track bolus administration times for plotting
# Process dosing regimen
for dose in dosing_regimen:
    if dose['type'] == 'bolus':
        # Record bolus time for plotting
        bolus_times.append((dose['time'], dose['dose']))
        
        # For simulation purposes, model bolus as very short infusion
        start_idx = int(dose['time'] / dt)
        end_idx = int((dose['time'] + dose['duration']) / dt)
        if start_idx < len(infusion_rates) and end_idx < len(infusion_rates):
            # Convert mg/kg bolus over duration to mcg/kg/min
            bolus_rate = dose['dose'] * 1000 / dose['duration']  # mcg/kg/min
            infusion_rates[start_idx:end_idx+1] = bolus_rate

Processes bolus doses by converting them to very short, high-rate infusions
For calculation purposes, it converts the bolus dose (mg/kg) to an equivalent infusion rate (mcg/kg/min)
Stores the calculated rates in the infusion_rates array at the appropriate time indices
# System of differential equations
def pk_model(t, y, infusion_func):
    # y[0]: amount in central compartment (mcg)
    # y[1]: amount in peripheral compartment 1 (mcg)
    # y[2]: amount in peripheral compartment 2 (mcg)
    # y[3]: effect site concentration (mcg/mL)
    
    # Get infusion rate at current time
    inf_rate = infusion_func(t)
    
    # Compute compartment concentrations in mcg/mL
    c1 = y[0] / (v1 * 1000)  # central compartment concentration in mcg/mL (v1 is in L)
    
    # Differential equations
    dy0dt = inf_rate * weight - k10 * y[0] - k12 * y[0] - k13 * y[0] + k21 * y[1] + k31 * y[2]
    dy1dt = k12 * y[0] - k21 * y[1]
    dy2dt = k13 * y[0] - k31 * y[2]
    dy3dt = keo * (c1 - y[3])
    
    return [dy0dt, dy1dt, dy2dt, dy3dt]

This is the core mathematical model - a system of differential equations describing drug movement
The equations represent:
dy0dt: Rate of change in central compartment (input minus elimination and distribution, plus redistribution)
dy1dt: Rate of change in rapid peripheral compartment
dy2dt: Rate of change in slow peripheral compartment
dy3dt: Rate of change in effect site concentration
Key part: dy3dt = keo * (c1 - y[3]) models effect site equilibration based on the concentration gradient
# Interpolation function for infusion rates
def infusion_func(t_val):
    idx = int(t_val / dt)
    if idx < 0 or idx >= len(infusion_rates):
        return 0
    return infusion_rates[idx]

Helper function that provides the infusion rate at any time point
Returns 0 if time is outside the simulation range
# Initial conditions
y0 = [0, 0, 0, 0]

Starting conditions: no drug in any compartment at time zero
# Solve ODE system
solution = solve_ivp(
    pk_model, 
    [t_start, t_end], 
    y0, 
    t_eval=t, 
    args=(infusion_func,),
    method='BDF',
    rtol=1e-4,
    atol=1e-6
)

Uses SciPy's ODE solver with the Backward Differentiation Formula method
BDF is chosen because this system is "stiff" (involving processes occurring at very different timescales)
Provides tolerance parameters for acceptable error in the solution
# Extract results
amounts = solution.y
cp = amounts[0] / (v1 * 1000)  # Plasma concentration in mcg/mL (v1 is in L)
ce = amounts[3]                # Effect site concentration already in mcg/mL

This is where Cp (plasma concentration) and Ce (effect site concentration) are calculated:
cp: Amount in central compartment divided by volume (converts to concentration)
ce: Effect site concentration directly from the ODE solution
These values are stored as arrays with the same length as the time array
# Calculate BIS using Hill equation
bis = E0 - (E0 - Emax) * (ce**gamma) / (EC50**gamma + ce**gamma)

This is the Hill equation, a core component of the model
It calculates the BIS value (measure of sedation level) based on effect site concentration
The Hill equation is a sigmoid function commonly used in pharmacology to model drug effects
Origin: Named after A.V. Hill's work in the early 1900s on oxygen binding to hemoglobin
Mathematical form: E = Emax × C^γ / (EC50^γ + C^γ)
Components:
E0: Baseline effect (BIS of 100 when awake)
Emax: Maximum effect (BIS of 0 under deep anesthesia)
ce: Effect site concentration
EC50: Concentration producing 50% of maximum effect
gamma: Hill coefficient determining curve steepness
Plotting Function
def plot_results(t, infusion_rates, bolus_times, cp, ce, bis, wake_time=None):

Function to visualize simulation results
Creates a figure with three subplots:
Infusion rates and bolus markers
Plasma and effect site concentrations
BIS values over time
fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 14), sharex=True)

Creates a figure with three vertically stacked subplots sharing the same x-axis (time)
# Plot infusion rates (excluding boluses)
ax1.plot(t, infusion_rates, 'k-', label='Infusion Rate')

Plots infusion rates as a black line
# Plot concentrations
ax2.plot(t, cp, 'b-', label='Plasma Conc. (Cp)')
ax2.plot(t, ce, 'r-', label='Effect Site Conc. (Ce)')

Plots Cp (blue) and Ce (red) concentrations on the same axis
This visualizes the delay between plasma and effect site concentrations due to keo
# Plot BIS
ax3.plot(t, bis, 'g-', label='BIS')

Plots the BIS values calculated using the Hill equation
Main Function
def main():

Entry point of the program that ties everything together
# Get model parameters using patient demographics
model_params = get_schneider_parameters(weight=weight, height=height, age=age, sex=sex)

Obtains individualized PK parameters based on patient characteristics
# Run simulation
t, infusion_display, bolus_times, cp, ce, bis, wake_time = run_simulation(
    model_params,
    weight=weight,
    dosing_regimen=dosing_regimen,
    total_time=total_time,
    dt=time_step
)

Executes the simulation and stores all results
Key outputs include:
Time array
Infusion rates
Calculated concentrations (Cp and Ce)
BIS values
# Plot results
fig = plot_results(t, infusion_display, bolus_times, cp, ce, bis, wake_time)
plt.show()

Generates and displays the visualization
Shows the complete time course of drug administration and effects
Key Concepts Explanation
Hill Function in Detail:


Mathematical formula: E = E0 - (E0 - Emax) * (C^gamma / (EC50^gamma + C^gamma))
Origin: Developed by A.V. Hill to model cooperative binding, now widely used in pharmacology
In this code: Relates effect site concentration to clinical effect (BIS)
Parameters:
E0 (100): Maximum BIS value (fully awake)
Emax (0): Minimum BIS value (fully anesthetized)
EC50 (2.2 mcg/mL): Concentration at 50% effect
gamma (1.8): Steepness of the curve (higher = more "all or nothing" response)
The Hill equation creates a sigmoid (S-shaped) curve that accurately models the non-linear relationship between drug concentration and effect
keo Parameter:


Represents the rate constant for equilibration between plasma and effect site
Units: 1/min (meaning it's a fractional rate of change per minute)
Value of 0.46/min means roughly a 2-3 minute half-time for equilibration
Used in the differential equation: dy3dt = keo * (c1 - y[3])
This equation models a first-order process driven by the concentration gradient
Higher keo = faster equilibration = quicker onset of effect
Determined experimentally by comparing time course of plasma concentrations with observed effects
Cp and Ce Calculation and Storage:


Cp (Plasma Concentration):
Calculated as: cp = amounts[0] / (v1 * 1000)
Represents drug amount in central compartment divided by volume
Units: mcg/mL
Ce (Effect Site Concentration):
Solved directly in the ODE system as the fourth state variable: y[3]
Governed by the equation: dy3dt = keo * (c1 - y[3])
Units: mcg/mL
Both are stored as NumPy arrays with the same length as the time array
These arrays are used for:
Plotting concentration-time curves in the second subplot
Calculating BIS values using the Hill equation
Determining clinical metrics like time to wake-up
Each value corresponds to a specific time point in the simulation
The arrays are passed between functions, allowing for analysis of the entire time course
Three-Compartment Model Structure:


The code implements a three-compartment model plus effect site:
Central compartment (v1): Blood/plasma where drug is initially distributed
Rapid peripheral compartment (v2): Well-perfused tissues (e.g., brain, liver)
Slow peripheral compartment (v3): Poorly-perfused tissues (e.g., fat, muscle)
Effect site: Theoretical site where drug exerts its effect (not a physical compartment)
The differential equations model the movement between these compartments:
 dy0dt = inf_rate * weight - k10 * y[0] - k12 * y[0] - k13 * y[0] + k21 * y[1] + k31 * y[2]dy1dt = k12 * y[0] - k21 * y[1]dy2dt = k13 * y[0] - k31 * y[2]dy3dt = keo * (c1 - y[3])


This structure is chosen because it accurately reflects propofol's distribution in the body:
Propofol is highly lipophilic, leading to complex distribution patterns
Simple one or two-compartment models don't capture the clinical behavior well
The three-compartment model plus effect site has been validated in clinical studies
ODE Solver Selection:


The code uses solve_ivp with the 'BDF' (Backward Differentiation Formula) method:
 solution = solve_ivp(    pk_model,     [t_start, t_end],     y0,     t_eval=t,     args=(infusion_func,),    method='BDF',    rtol=1e-4,    atol=1e-6)


BDF is specifically chosen because:
This is a "stiff" system with processes occurring at very different time scales
Elimination rate (k10) may be much slower than distribution rates (k12, k13)
BDF handles stiff systems more efficiently than explicit methods
The tolerance parameters (rtol, atol) control solution accuracy
Wake-Up Time Determination:

 # Find wake-up time (Ce < 1 mcg/mL or BIS > 80) after end of infusion
wake_time = None

# Find the end of the last infusion
end_of_infusion = 0
for dose in dosing_regimen:
    if dose['type'] == 'infusion':
        end_time = dose['time'] + dose['duration']
        if end_time > end_of_infusion:
            end_of_infusion = end_time

# Find wake-up time after end of infusion
for i in range(len(t)):
    if t[i] > end_of_infusion and (ce[i] < 1 or bis[i] > 80):
        wake_time = t[i]
        break


The code defines wake-up based on clinical thresholds:
Ce < 1 mcg/mL: Effect site concentration below awakening threshold
BIS > 80: BIS value indicating light sedation/approaching consciousness
It first identifies when the last infusion ends, then looks for the first time point after that where either condition is met
This is clinically relevant for predicting recovery time in real patients
Clinical Metrics Calculation:

 # Time to BIS < 60 (surgical anesthesia)
time_to_surgical = None
for i in range(len(t)):
    if bis[i] < 60:
        time_to_surgical = t[i]
        break


The code calculates several useful clinical metrics:
Time to surgical anesthesia (BIS < 60)
Time to therapeutic concentration (Ce > 3 mcg/mL)
Total drug used over the entire case
These metrics help clinicians assess the efficacy and efficiency of the dosing regimen
Graph Creation and Visualization:


The plot_results function creates a comprehensive three-panel visualization:
Top panel: Infusion rates and bolus markers
Middle panel: Plasma and effect site concentrations
Bottom panel: BIS values
This visualization style was chosen because:
It allows for direct comparison of input (dosing) to outputs (concentrations and effects)
It clearly shows the time delays between drug administration, plasma levels, and clinical effect
The clinically relevant thresholds (Ce = 1 mcg/mL, BIS = 80) are marked with horizontal lines
Dosing Regimen Flexibility:

 # Default dosing regimen if none provided
if dosing_regimen is None:
    dosing_regimen = [
        {'type': 'bolus', 'time': 0, 'dose': 2.0, 'duration': 0.1},  # mg/kg bolus at t=0
        {'type': 'infusion', 'time': 0.1, 'rate': 166.67, 'duration': 10},  # mcg/kg/min for 10 min
        # ... additional default infusions
    ]


The code allows for flexible dosing regimens:
Boluses and infusions can be combined
Infusions can change rates during the simulation
Default values are provided but can be overridden
This flexibility allows the model to simulate real-world clinical practice:
Induction (initial bolus)
Initial high-rate infusion to reach therapeutic levels
Maintenance infusion at lower rates
Intermittent boluses for increased surgical stimulation
Summary Statistics Calculation:

 print("\n===== SIMULATION SUMMARY =====")
print(f"Patient: {weight}kg, {height}cm, {age}y, {sex}")

if wake_time:
    print(f"Wake-up time: {wake_time:.2f} minutes after start")
    print(f"Recovery time: {wake_time - 120:.2f} minutes after end of infusion")


The code calculates and displays useful summary statistics:
Patient demographics
Wake-up time (absolute and relative to infusion end)
Maximum concentrations reached
Minimum BIS value (deepest level of anesthesia)
Total drug usage and usage per minute
In summary, this code implements a comprehensive pharmacokinetic-pharmacodynamic (PK/PD) model for propofol anesthesia. The three-compartment model with effect site accurately captures propofol's distribution in the body, while the Hill equation models the relationship between drug concentration and clinical effect (BIS). The keo parameter models the time delay between plasma and effect site concentrations, addressing the clinical observation that drug effects lag behind plasma levels. The simulation allows for flexible dosing regimens and calculates clinically relevant metrics that would be useful for anesthesiologists planning propofol administration.
The plasma concentration (Cp) and effect site concentration (Ce) values are calculated at each time point and stored in arrays that parallel the time array. These arrays serve as the basis for visualization and clinical metric calculations, providing a comprehensive picture of the drug's behavior over time.

Yes, it's definitely possible to keep the same program structure and add additional PK model functions that a user could choose from. This would make the program more versatile without requiring major changes to the overall architecture. Here's how you could implement this:
1. Create Model Parameter Functions
Create separate functions for each PK model, similar to the existing get_schneider_parameters():
def get_marsh_parameters(weight=70, height=170, age=40, sex='male'):
    """Calculate Marsh model parameters based on patient characteristics."""
    # Define Marsh model parameters
    v1 = 0.228 * weight  # L - Central compartment
    v2 = 0.463 * weight  # L - Rapid peripheral compartment
    v3 = 2.893 * weight  # L - Slow peripheral compartment
    
    # Define clearances
    cl1 = 0.033 * weight  # L/min
    cl2 = 0.076 * weight  # L/min
    cl3 = 0.0064 * weight  # L/min
    
    # Calculate rate constants
    k10 = cl1 / v1
    k12 = cl2 / v1
    k13 = cl3 / v1
    k21 = cl2 / v2
    k31 = cl3 / v3
    
    # Effect site parameters and PD parameters can remain the same
    keo = 0.26  # 1/min - different for Marsh model
    EC50 = 2.2  # mcg/mL
    gamma = 1.8  # Hill coefficient
    E0 = 100     # Baseline BIS value
    Emax = 0     # Maximum effect (lowest BIS)
    
    return {
        'v1': v1, 'v2': v2, 'v3': v3,
        'cl1': cl1, 'cl2': cl2, 'cl3': cl3,
        'k10': k10, 'k12': k12, 'k13': k13, 'k21': k21, 'k31': k31,
        'keo': keo,
        'EC50': EC50, 'gamma': gamma, 'E0': E0, 'Emax': Emax
    }

def get_eleveld_parameters(weight=70, height=170, age=40, sex='male'):
    """Calculate Eleveld model parameters based on patient characteristics."""
    # Implementation of the Eleveld model parameters
    # This would include more complex calculations based on age, weight, height, sex
    # ...
    
    return {
        # Parameter dictionary similar to above
    }



2. Create a Model Selection Function
Add a function that returns the appropriate parameter function based on user choice:
def get_pk_model_function(model_name):
    """
    Return the appropriate PK model function based on model name.
    
    Args:
        model_name (str): Name of the PK model ('schneider', 'marsh', 'eleveld', etc.)
        
    Returns:
        function: The corresponding parameter calculation function
    """
    model_functions = {
        'schneider': get_schneider_parameters,
        'marsh': get_marsh_parameters,
        'eleveld': get_eleveld_parameters,
        # Add more models as needed
    }
    
    if model_name.lower() not in model_functions:
        raise ValueError(f"Unknown model: {model_name}. Available models: {', '.join(model_functions.keys())}")
    
    return model_functions[model_name.lower()]


3. Modify the Main Function
Update the main function to accept a model selection parameter:
def main(model_name='schneider'):
    # === USER EDITABLE SECTION - START ===
    
    # Patient parameters
    weight = 70      # kg
    height = 170     # cm
    age = 40         # years
    sex = 'male'     # 'male' or 'female'
    
    # Dosing regimen and simulation parameters remain the same
    # ...
    
    # === USER EDITABLE SECTION - END ===
    
    # Get the appropriate model function
    model_function = get_pk_model_function(model_name)
    
    # Get model parameters using patient demographics
    model_params = model_function(weight=weight, height=height, age=age, sex=sex)
    
    # Rest of the function remains unchanged
    # ...
    
    # Add model name to the summary printout
    print(f"PK/PD Model: {model_name.capitalize()}")
    print(f"Patient: {weight}kg, {height}cm, {age}y, {sex}")


4. Create a Simple UI for Model Selection
For command-line usage, you could add argument parsing:
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description='Propofol PK/PD Simulation')
    parser.add_argument('--model', type=str, default='schneider', 
                        choices=['schneider', 'marsh', 'eleveld'],
                        help='PK/PD model to use for simulation')
    # Add more arguments as needed
    
    args = parser.parse_args()
    main(model_name=args.model)


5. Additional Enhancements
Model Parameter Comparison:

 
def compare_models(weight, height, age, sex, dosing_regimen=None):
    """Run simulations with different PK models and compare results."""
    models = ['schneider', 'marsh', 'eleveld']
    results = {}
    
    for model in models:
        model_function = get_pk_model_function(model)
        model_params = model_function(weight=weight, height=height, age=age, sex=sex)
        results[model] = run_simulation(model_params, weight, dosing_regimen)
    
    # Plot comparative results
    plot_model_comparison(results)
    
def plot_model_comparison(results):
    """Plot comparative results from different PK models."""
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 14), sharex=True)
    
    # Different colors for different models
    colors = {'schneider': 'b', 'marsh': 'r', 'eleveld': 'g'}
    
    # Plot Cp for each model
    for model, (t, _, _, cp, ce, bis, _) in results.items():
        ax1.plot(t, cp, color=colors[model], label=f'{model.capitalize()} Cp')
    
    # Similar plotting for Ce and BIS
    # ...
    
    plt.tight_layout()
    plt.show()



Custom Pharmacodynamic Parameters: Allow users to specify different EC50, gamma values for individual patient sensitivity.


Model Parameter Display: Add functionality to display the calculated parameters for educational purposes.


This approach leverages the existing structure while making the program more versatile. The current functions for running simulations and plotting results can be used without significant changes since all PK models will return parameter dictionaries with the same structure. The only adaptation needed is in how those parameters are calculated for each model.
Yes, it's definitely possible to add the Minto model for combined propofol and remifentanil with interaction effects on BIS, while maintaining the basic structure of the original code. The Minto model is specifically designed to handle drug interactions, particularly between propofol and remifentanil, which show synergistic effects on BIS.
Here's how you could implement this:
1. Create Remifentanil PK Parameter Function
def get_minto_remifentanil_parameters(weight=70, height=170, age=40, sex='male'):
    """
    Calculate Minto model parameters for remifentanil based on patient characteristics.
    
    Returns:
        dict: Dictionary containing all PK parameters for remifentanil
    """
    # Lean body mass calculation
    if sex.lower() == 'male':
        lbm = 1.1 * weight - 128 * (weight/height)**2
    else:  # female
        lbm = 1.07 * weight - 148 * (weight/height)**2
    
    # Volume calculations for remifentanil
    v1r = 5.1 - 0.0201 * (age - 40) + 0.072 * (lbm - 55)  # L - Central compartment
    v2r = 9.82 - 0.0811 * (age - 40) + 0.108 * (lbm - 55)  # L - Rapid peripheral compartment
    v3r = 5.42  # L - Slow peripheral compartment
    
    # Clearance calculations for remifentanil
    cl1r = 2.6 - 0.0162 * (age - 40) + 0.0191 * (lbm - 55)  # L/min
    cl2r = 2.05 - 0.0301 * (age - 40)  # L/min
    cl3r = 0.076 - 0.00113 * (age - 40)  # L/min
    
    # Calculate rate constants
    k10r = cl1r / v1r
    k12r = cl2r / v1r
    k13r = cl3r / v1r
    k21r = cl2r / v2r
    k31r = cl3r / v3r
    
    # Effect site parameters 
    keor = 0.595  # 1/min - faster equilibration for remifentanil
    
    # PD parameters for remifentanil
    EC50r = 19.3  # ng/mL
    gammar = 1.89  # Hill coefficient
    
    return {
        'v1r': v1r, 'v2r': v2r, 'v3r': v3r,
        'cl1r': cl1r, 'cl2r': cl2r, 'cl3r': cl3r,
        'k10r': k10r, 'k12r': k12r, 'k13r': k13r, 'k21r': k21r, 'k31r': k31r,
        'keor': keor,
        'EC50r': EC50r, 'gammar': gammar
    }


2. Create a Combined Minto Model Function
def get_minto_combined_parameters(weight=70, height=170, age=40, sex='male'):
    """
    Calculate parameters for combined propofol-remifentanil Minto model.
    
    Returns:
        dict: Combined dictionary with parameters for both drugs and interaction parameters
    """
    # Get propofol parameters using Schneider model
    propofol_params = get_schneider_parameters(weight, height, age, sex)
    
    # Get remifentanil parameters
    remifentanil_params = get_minto_remifentanil_parameters(weight, height, age, sex)
    
    # Interaction parameters for BIS response
    interaction_params = {
        'alpha': 1.33,    # Interaction coefficient (>1 indicates synergy)
        'E0': 100,        # Baseline BIS value
        'Emax': 0,        # Maximum effect (lowest BIS)
        'gamma': 1.43     # Steepness of the response surface
    }
    
    # Combine all parameters
    combined_params = {**propofol_params, **remifentanil_params, **interaction_params}
    
    return combined_params


3. Modify the Run Simulation Function for Combined Model
def run_combined_simulation(model_params, weight=70, propofol_dosing=None, 
                           remifentanil_rate=0.05, total_time=180, dt=0.1):
    """
    Run PK/PD simulation for combined propofol-remifentanil using provided parameters.
    
    Args:
        model_params: Dictionary containing all required PK/PD parameters for both drugs
        weight: Patient weight in kg
        propofol_dosing: List of dictionaries describing propofol dosing events
        remifentanil_rate: Constant remifentanil infusion rate in mcg/kg/min
        total_time: Total simulation time in minutes
        dt: Time step for simulation in minutes
        
    Returns:
        tuple: (time, propofol_infusion_rates, bolus_times, cp_propofol, ce_propofol, 
                cp_remi, ce_remi, bis, wake_time)
    """
    # Extract propofol parameters
    v1 = model_params['v1']
    k10 = model_params['k10']
    k12 = model_params['k12']
    k13 = model_params['k13']
    k21 = model_params['k21']
    k31 = model_params['k31']
    keo = model_params['keo']
    
    # Extract remifentanil parameters
    v1r = model_params['v1r']
    k10r = model_params['k10r']
    k12r = model_params['k12r']
    k13r = model_params['k13r']
    k21r = model_params['k21r']
    k31r = model_params['k31r']
    keor = model_params['keor']
    
    # Extract interaction parameters for BIS response
    alpha = model_params['alpha']
    E0 = model_params['E0']
    Emax = model_params['Emax']
    gamma = model_params['gamma']
    EC50p = model_params['EC50']    # EC50 for propofol
    EC50r = model_params['EC50r']   # EC50 for remifentanil
    
    # Default propofol dosing regimen if none provided
    if propofol_dosing is None:
        propofol_dosing = [
            {'type': 'bolus', 'time': 0, 'dose': 2.0, 'duration': 0.1},  # mg/kg bolus at t=0
            {'type': 'infusion', 'time': 0.1, 'rate': 166.67, 'duration': 10},  # mcg/kg/min for 10 min
            {'type': 'infusion', 'time': 10.1, 'rate': 133.33, 'duration': 10},  # mcg/kg/min for 10 min
            {'type': 'infusion', 'time': 20.1, 'rate': 100, 'duration': 99.9},  # mcg/kg/min until 120 min
        ]
    
    # Simulation time settings
    t_start = 0
    t_end = total_time  # minutes
    t = np.arange(t_start, t_end + dt, dt)
    
    # Create propofol infusion rate array and track bolus times
    propofol_rates = np.zeros_like(t)
    bolus_times = []
    
    # Process propofol dosing regimen (same as original code)
    for dose in propofol_dosing:
        if dose['type'] == 'bolus':
            bolus_times.append((dose['time'], dose['dose']))
            start_idx = int(dose['time'] / dt)
            end_idx = int((dose['time'] + dose['duration']) / dt)
            if start_idx < len(propofol_rates) and end_idx < len(propofol_rates):
                bolus_rate = dose['dose'] * 1000 / dose['duration']  # mcg/kg/min
                propofol_rates[start_idx:end_idx+1] = bolus_rate
        elif dose['type'] == 'infusion':
            start_idx = int(dose['time'] / dt)
            end_idx = int((dose['time'] + dose['duration']) / dt)
            if start_idx < len(propofol_rates) and end_idx < len(propofol_rates):
                propofol_rates[start_idx:end_idx+1] = dose['rate']
    
    # Create constant remifentanil infusion rate
    remifentanil_rates = np.ones_like(t) * remifentanil_rate
    
    # System of differential equations for both drugs
    def pkpd_model(t, y, propofol_func, remifentanil_func):
        # y[0:3]: propofol amounts in compartments (mcg)
        # y[4]: propofol effect site concentration (mcg/mL)
        # y[5:7]: remifentanil amounts in compartments (mcg)
        # y[8]: remifentanil effect site concentration (ng/mL)
        
        # Get infusion rates at current time
        propofol_rate = propofol_func(t)
        remifentanil_rate = remifentanil_func(t)
        
        # Compute compartment concentrations
        cp = y[0] / (v1 * 1000)  # propofol central concentration in mcg/mL
        cr = y[4] / (v1r * 1000) * 1000  # remifentanil central concentration in ng/mL
        
        # Propofol differential equations
        dy0dt = propofol_rate * weight - k10 * y[0] - k12 * y[0] - k13 * y[0] + k21 * y[1] + k31 * y[2]
        dy1dt = k12 * y[0] - k21 * y[1]
        dy2dt = k13 * y[0] - k31 * y[2]
        dy3dt = keo * (cp - y[3])
        
        # Remifentanil differential equations (note: remifentanil rate in mcg/kg/min)
        dy4dt = remifentanil_rate * weight - k10r * y[4] - k12r * y[4] - k13r * y[4] + k21r * y[5] + k31r * y[6]
        dy5dt = k12r * y[4] - k21r * y[5]
        dy6dt = k13r * y[4] - k31r * y[6]
        dy7dt = keor * (cr - y[7])
        
        return [dy0dt, dy1dt, dy2dt, dy3dt, dy4dt, dy5dt, dy6dt, dy7dt]
    
    # Interpolation functions for infusion rates
    def propofol_func(t_val):
        idx = int(t_val / dt)
        if idx < 0 or idx >= len(propofol_rates):
            return 0
        return propofol_rates[idx]
    
    def remifentanil_func(t_val):
        idx = int(t_val / dt)
        if idx < 0 or idx >= len(remifentanil_rates):
            return 0
        return remifentanil_rates[idx]
    
    # Initial conditions for all compartments (propofol and remifentanil)
    y0 = [0, 0, 0, 0, 0, 0, 0, 0]
    
    # Solve ODE system
    solution = solve_ivp(
        pkpd_model, 
        [t_start, t_end], 
        y0, 
        t_eval=t, 
        args=(propofol_func, remifentanil_func),
        method='BDF',
        rtol=1e-4,
        atol=1e-6
    )
    
    # Extract results
    amounts = solution.y
    cp_propofol = amounts[0] / (v1 * 1000)  # Propofol plasma concentration in mcg/mL
    ce_propofol = amounts[3]                # Propofol effect site concentration in mcg/mL
    cp_remi = amounts[4] / (v1r * 1000) * 1000  # Remifentanil plasma concentration in ng/mL
    ce_remi = amounts[7]                    # Remifentanil effect site concentration in ng/mL
    
    # Calculate BIS using modified Hill equation for drug interaction
    # Normalized propofol and remifentanil concentrations
    u_propofol = ce_propofol / EC50p
    u_remi = ce_remi / EC50r
    
    # Combined drug effect using Minto model (response surface)
    U = u_propofol + u_remi - alpha * u_propofol * u_remi/(u_propofol + u_remi)
    bis = E0 - (E0 - Emax) * (U**gamma) / (1 + U**gamma)
    
    # Determine wake-up time as before, but now based on combined effect
    wake_time = None
    end_of_infusion = 0
    for dose in propofol_dosing:
        if dose['type'] == 'infusion':
            end_time = dose['time'] + dose['duration']
            if end_time > end_of_infusion:
                end_of_infusion = end_time
    
    for i in range(len(t)):
        if t[i] > end_of_infusion and bis[i] > 80:
            wake_time = t[i]
            break
    
    # Create infusion display for graph (excluding boluses)
    propofol_display = np.zeros_like(propofol_rates)
    for dose in propofol_dosing:
        if dose['type'] == 'infusion':
            start_idx = int(dose['time'] / dt)
            end_idx = int((dose['time'] + dose['duration']) / dt)
            if start_idx < len(propofol_display) and end_idx < len(propofol_display):
                propofol_display[start_idx:end_idx+1] = dose['rate']
    
    return (t, propofol_display, bolus_times, cp_propofol, ce_propofol, 
            cp_remi, ce_remi, bis, wake_time)


4. Create a Modified Plot Function




I'll continue with the code for the combined propofol and remifentanil simulation with the Minto model. Here's the remaining part of the plot function:
def plot_combined_results(t, propofol_rates, bolus_times, cp_propofol, ce_propofol, 
                         cp_remi, ce_remi, bis, wake_time=None):
    """
    Plot the results of the combined propofol-remifentanil PK/PD simulation.
    """
    fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(12, 16), sharex=True)
    
    # Plot propofol infusion rates (same as original)
    ax1.plot(t, propofol_rates, 'k-', label='Propofol Rate')
    for bolus_time, bolus_dose in bolus_times:
        ax1.axvline(x=bolus_time, color='r', linestyle='--')
        ax1.annotate(f'Bolus: {bolus_dose} mg/kg', 
                    xy=(bolus_time, propofol_rates.max() * 0.9),
                    xytext=(bolus_time + 2, propofol_rates.max() * 0.9),
                    arrowprops=dict(arrowstyle='->'))
    ax1.set_ylabel('Propofol Rate (mcg/kg/min)')
    ax1.set_title('Propofol Infusion Rate')
    ax1.grid(True)
    
    # Plot remifentanil concentration
    ax2.plot(t, cp_remi, 'b-', label='Plasma')
    ax2.plot(t, ce_remi, 'r-', label='Effect Site')
    ax2.set_ylabel('Remifentanil Conc. (ng/mL)')
    ax2.set_title('Remifentanil Concentration')
    ax2.legend()
    ax2.grid(True)
    
    # Plot propofol concentration
    ax3.plot(t, cp_propofol, 'b-', label='Plasma')
    ax3.plot(t, ce_propofol, 'r-', label='Effect Site')
    ax3.set_ylabel('Propofol Conc. (mcg/mL)')
    ax3.set_title('Propofol Concentration')
    ax3.legend()
    ax3.grid(True)
    
    # Plot BIS
    ax4.plot(t, bis, 'g-')
    ax4.axhline(y=60, color='k', linestyle='--', label='BIS 60')
    ax4.axhline(y=40, color='k', linestyle=':', label='BIS 40')
    
    # Mark wake-up time if available
    if wake_time is not None:
        ax4.axvline(x=wake_time, color='m', linestyle='-.')
        ax4.annotate(f'Wake-up: {wake_time:.1f} min', 
                    xy=(wake_time, 60),
                    xytext=(wake_time + 2, 60),
                    arrowprops=dict(arrowstyle='->'))
    
    ax4.set_ylabel('BIS Value')
    ax4.set_xlabel('Time (minutes)')
    ax4.set_title('BIS Response')
    ax4.grid(True)
    ax4.set_ylim(0, 100)
    
    plt.tight_layout()
    plt.show()


5. Create a Main Function for Using the Combined Model
def run_combined_minto_simulation(weight=70, height=170, age=40, sex='male', 
                                 propofol_dosing=None, remifentanil_rate=0.05, 
                                 total_time=180, dt=0.1):
    """
    Main function to run and plot the combined Minto model simulation.
    
    Args:
        weight: Patient weight in kg
        height: Patient height in cm
        age: Patient age in years
        sex: Patient sex ('male' or 'female')
        propofol_dosing: List of dictionaries describing propofol dosing events
        remifentanil_rate: Remifentanil infusion rate in mcg/kg/min
        total_time: Total simulation time in minutes
        dt: Time step for simulation in minutes
    """
    # Get combined model parameters
    model_params = get_minto_combined_parameters(weight, height, age, sex)
    
    # Run the simulation
    (t, propofol_rates, bolus_times, cp_propofol, ce_propofol, 
     cp_remi, ce_remi, bis, wake_time) = run_combined_simulation(
        model_params, weight, propofol_dosing, remifentanil_rate, total_time, dt)
    
    # Plot results
    plot_combined_results(t, propofol_rates, bolus_times, cp_propofol, ce_propofol, 
                         cp_remi, ce_remi, bis, wake_time)
    
    # Return the results
    return {
        'time': t,
        'propofol_rates': propofol_rates,
        'bolus_times': bolus_times,
        'cp_propofol': cp_propofol,
        'ce_propofol': ce_propofol,
        'cp_remi': cp_remi,
        'ce_remi': ce_remi,
        'bis': bis,
        'wake_time': wake_time
    }


6. Example Usage
# Example usage of the combined Minto model
if __name__ == '__main__':
    # Define a sample propofol dosing regimen
    propofol_dosing = [
        {'type': 'bolus', 'time': 0, 'dose': 1.5, 'duration': 0.1},  # Lower initial bolus
        {'type': 'infusion', 'time': 0.1, 'rate': 120, 'duration': 15},  # mcg/kg/min
        {'type': 'infusion', 'time': 15.1, 'rate': 100, 'duration': 15},  # mcg/kg/min
        {'type': 'infusion', 'time': 30.1, 'rate': 80, 'duration': 149.9},  # mcg/kg/min
    ]
    
    # Run the simulation for a 70 kg, 170 cm, 40-year-old male patient
    # with remifentanil infusion at 0.1 mcg/kg/min
    results = run_combined_minto_simulation(
        weight=70, 
        height=170, 
        age=40, 
        sex='male',
        propofol_dosing=propofol_dosing,
        remifentanil_rate=0.1,  # moderate remifentanil infusion
        total_time=180,  # 3 hours simulation
        dt=0.1
    )
    
    # Print wake-up time
    if results['wake_time'] is not None:
        print(f"Predicted wake-up time: {results['wake_time']:.1f} minutes")
    else:
        print("Wake-up time not reached within simulation duration")


This implementation includes the key components of the Minto model for combined propofol and remifentanil effects on BIS. The model captures the synergistic interaction between the two drugs using the interaction parameter alpha. When alpha > 1, the drugs show synergistic effects, meaning that the combined effect is greater than the sum of the individual effects.
The modified simulation can be used to:
Optimize drug dosing regimens with both propofol and remifentanil
Predict BIS values based on different combinations of propofol and remifentanil
Estimate wake-up times with combined drug therapy
Explore the synergistic effects between propofol and remifentanil
This implementation maintains the structure of the original code while expanding it to include the Minto model for drug interactions.

